<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Danh S√°ch C√¥ng Vi·ªác - PickleDB</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --primary-blue: #4361ee;
        --primary-red: #e63946;
        --primary-green: #06d6a0;
        --text-dark: #2b2d42;
        --text-light: #ffffff;
        --bg-light: #f8f9fa;
        --border-color: #dee2e6;
        --success: #06d6a0;
        --badge-blue: #4361ee;
        --warning: #f0ad4e;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
        font-family: "Roboto", sans-serif;
      }

      body {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 0;
        margin: 0;
      }

      .dashboard-container {
        max-width: 920px;
        margin: 0 auto;
        background-color: var(--bg-light);
        min-height: 100vh;
        box-shadow: 0 0 40px rgba(0, 0, 0, 0.2);
      }

      /* Header */
      .header {
        background: linear-gradient(135deg, #4361ee 0%, #5a7af8 100%);
        color: var(--text-light);
        padding: 35px 40px;
        text-align: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }

      .header h1 {
        font-size: 36px;
        font-weight: 700;
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
      }

      .header h1::before {
        content: "‚úì";
        font-size: 40px;
        font-weight: 700;
        border: 3px solid white;
        border-radius: 6px;
        padding: 2px 8px;
      }

      .cluster-status {
        display: flex;
        justify-content: center;
        gap: 15px;
        flex-wrap: wrap;
        margin-top: 15px;
      }

      .node-info {
        background-color: var(--primary-red);
        color: var(--text-light);
        padding: 12px 24px;
        border-radius: 8px;
        display: inline-flex;
        align-items: center;
        gap: 10px;
        font-size: 16px;
        font-weight: 500;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        transition: all 0.3s;
      }

      .node-info.standby {
        background-color: var(--warning);
      }

      .node-info.active {
        background-color: var(--primary-green);
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.85;
        }
      }

      .node-info::before {
        content: "üóÑ";
        font-size: 20px;
      }

      .status-indicator {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        display: inline-block;
        margin-right: 5px;
      }

      .status-indicator.online {
        background-color: #5cb85c;
        box-shadow: 0 0 8px #5cb85c;
      }

      .status-indicator.offline {
        background-color: #999;
      }

      .failover-alert {
        background-color: #fff3cd;
        border: 2px solid #ffc107;
        color: #856404;
        padding: 15px 20px;
        border-radius: 8px;
        margin: 20px 40px 0;
        display: none;
        align-items: center;
        gap: 10px;
        font-weight: 500;
      }

      .failover-alert.show {
        display: flex;
      }

      .failover-alert::before {
        content: "‚ö†Ô∏è";
        font-size: 24px;
      }

      /* Content */
      .content {
        padding: 40px;
        background-color: white;
      }

      .section-title {
        color: var(--primary-blue);
        font-size: 28px;
        font-weight: 700;
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 3px solid var(--primary-blue);
        display: inline-block;
      }

      /* Form Single Task */
      .form-group {
        display: flex;
        gap: 12px;
        margin-bottom: 50px;
      }

      .input-text {
        flex-grow: 1;
        padding: 14px 20px;
        border: 2px solid var(--border-color);
        border-radius: 8px;
        font-size: 16px;
        transition: all 0.3s;
      }

      .input-text:focus {
        outline: none;
        border-color: var(--primary-blue);
        box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.1);
      }

      .input-textarea {
        width: 100%;
        padding: 14px 20px;
        border: 2px solid var(--border-color);
        border-radius: 8px;
        font-size: 16px;
        resize: vertical;
        min-height: 120px;
        margin-bottom: 15px;
        transition: all 0.3s;
      }

      .input-textarea:focus {
        outline: none;
        border-color: var(--primary-blue);
        box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.1);
      }

      /* Buttons */
      .btn {
        padding: 14px 28px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        color: var(--text-light);
        font-weight: 600;
        font-size: 16px;
        transition: all 0.3s;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      }

      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .btn-primary {
        background: linear-gradient(135deg, #4361ee 0%, #5a7af8 100%);
      }

      .btn-primary:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(67, 97, 238, 0.4);
      }

      .btn-primary::before {
        content: "+";
        font-size: 20px;
        font-weight: 700;
      }

      .btn-full {
        width: 100%;
        margin-bottom: 50px;
        padding: 16px 28px;
        font-size: 18px;
      }

      .btn-danger {
        background-color: var(--primary-red);
        padding: 10px 20px;
        font-size: 14px;
      }

      .btn-danger:hover:not(:disabled) {
        background-color: #d62828;
        transform: translateY(-2px);
      }

      /* Tasks List Header */
      .tasks-list-header {
        display: flex;
        align-items: center;
        gap: 15px;
        margin-bottom: 30px;
      }

      .badge {
        background-color: var(--badge-blue);
        color: var(--text-light);
        padding: 6px 18px;
        border-radius: 50%;
        font-size: 18px;
        font-weight: 700;
        min-width: 45px;
        height: 45px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 8px rgba(67, 97, 238, 0.3);
      }

      /* Filter Buttons */
      .filter-buttons {
        display: flex;
        gap: 12px;
        margin-bottom: 25px;
        flex-wrap: wrap;
      }

      .filter-btn {
        padding: 10px 24px;
        border: 2px solid var(--border-color);
        background-color: white;
        color: var(--text-dark);
        border-radius: 20px;
        cursor: pointer;
        font-size: 15px;
        font-weight: 500;
        transition: all 0.3s;
      }

      .filter-btn:hover {
        border-color: var(--primary-blue);
        color: var(--primary-blue);
      }

      .filter-btn.active {
        background: linear-gradient(135deg, #4361ee 0%, #5a7af8 100%);
        color: white;
        border-color: var(--primary-blue);
      }

      /* Task Items */
      .task-item {
        display: flex;
        align-items: center;
        gap: 15px;
        padding: 18px 20px;
        border: 2px solid var(--border-color);
        border-radius: 12px;
        margin-bottom: 12px;
        background-color: white;
        transition: all 0.3s;
      }

      .task-item:hover {
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.1);
        transform: translateY(-2px);
      }

      .task-item.completed {
        background-color: #f8f9fa;
        opacity: 0.7;
      }

      .task-checkbox {
        width: 24px;
        height: 24px;
        cursor: pointer;
        accent-color: var(--primary-blue);
      }

      .task-content {
        flex-grow: 1;
      }

      .task-title {
        font-size: 17px;
        color: var(--text-dark);
        font-weight: 500;
        line-height: 1.5;
      }

      .task-item.completed .task-title {
        text-decoration: line-through;
        color: #6c757d;
      }

      .task-meta {
        font-size: 13px;
        color: #6c757d;
        margin-top: 5px;
      }

      /* Empty State */
      .empty-state {
        text-align: center;
        padding: 80px 40px;
        color: #adb5bd;
      }

      .empty-state-icon {
        font-size: 80px;
        margin-bottom: 20px;
        opacity: 0.5;
      }

      .empty-state-text {
        font-size: 18px;
        color: #6c757d;
      }

      /* Messages */
      .message {
        padding: 14px 20px;
        border-radius: 8px;
        margin-bottom: 20px;
        display: none;
        font-weight: 500;
      }

      .message.show {
        display: block;
      }

      .error-message {
        background-color: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
      }

      .success-message {
        background-color: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
      }

      /* Loading */
      .loading {
        text-align: center;
        padding: 60px;
        color: var(--primary-blue);
        font-size: 18px;
      }

      /* Footer */
      .footer {
        text-align: center;
        padding: 25px;
        background-color: #f8f9fa;
        color: #6c757d;
        font-size: 15px;
        border-top: 1px solid var(--border-color);
      }

      /* Responsive */
      @media (max-width: 768px) {
        .content {
          padding: 25px;
        }

        .header h1 {
          font-size: 28px;
        }

        .section-title {
          font-size: 24px;
        }

        .form-group {
          flex-direction: column;
        }

        .cluster-status {
          flex-direction: column;
          align-items: center;
        }
      }
    </style>
  </head>
  <body>
    <div class="dashboard-container">
      <div class="header">
        <h1>Danh S√°ch C√¥ng Vi·ªác</h1>
        <div class="cluster-status">
          <div class="node-info" id="currentNodeDisplay">
            <span class="status-indicator online" id="nodeStatus"></span>
            <span
              >Node Ch√≠nh:
              <strong id="nodeUrl">http://127.0.0.1:4000</strong></span
            >
          </div>
        </div>
      </div>

      <div class="failover-alert" id="failoverAlert">
        <span id="failoverMessage">ƒêang chuy·ªÉn sang Node Ph·ª•...</span>
      </div>

      <div class="content">
        <div class="error-message message" id="errorMessage"></div>
        <div class="success-message message" id="successMessage"></div>

        <h2 class="section-title">Th√™m C√¥ng Vi·ªác</h2>
        <div class="form-group">
          <input
            type="text"
            class="input-text"
            id="taskInput"
            placeholder="T√™n c√¥ng vi·ªác..."
            onkeypress="handleKeyPress(event)"
          />
          <button class="btn btn-primary" onclick="addTask()">Th√™m</button>
        </div>

        <h2 class="section-title">Th√™m Nhi·ªÅu C√¥ng Vi·ªác</h2>
        <textarea
          class="input-textarea"
          id="bulkTaskInput"
          placeholder="Nh·∫≠p m·ªói c√¥ng vi·ªác tr√™n m·ªôt d√≤ng..."
        ></textarea>
        <button class="btn btn-primary btn-full" onclick="addBulkTasks()">
          Th√™m Nhi·ªÅu C√¥ng Vi·ªác
        </button>

        <div class="tasks-list-header">
          <h2 class="section-title" style="margin: 0; border: none; padding: 0">
            Danh S√°ch C√¥ng Vi·ªác
          </h2>
          <div class="badge" id="taskCount">0</div>
        </div>

        <div class="filter-buttons">
          <button class="filter-btn active" onclick="filterTasks('all', event)">
            T·∫•t C·∫£
          </button>
          <button class="filter-btn" onclick="filterTasks('active', event)">
            ƒêang L√†m
          </button>
          <button class="filter-btn" onclick="filterTasks('completed', event)">
            ƒê√£ Ho√†n Th√†nh
          </button>
          <button
            class="btn btn-danger"
            onclick="clearCompleted()"
            style="margin-left: auto"
          >
            X√≥a ƒê√£ Ho√†n Th√†nh
          </button>
        </div>

        <div id="tasksList">
          <div class="loading">ƒêang t·∫£i c√¥ng vi·ªác...</div>
        </div>
      </div>

      <div class="footer">
        PickleDB Todo List ¬© 2025 | Distributed Replication System
      </div>
    </div>

    <script>
      // C·∫•u h√¨nh Nodes
      const NODES = {
        primary: "http://127.0.0.1:4000",
        secondary: "http://127.0.0.1:4001",
      };

      let currentNode = NODES.primary;
      let tasks = [];
      let currentFilter = "all";
      let isFailover = false;
      let healthCheckInterval;

      document.addEventListener("DOMContentLoaded", function () {
        initializeApp();
      });

      async function initializeApp() {
        await checkNodeHealth();
        await loadTasks();
        startHealthCheck();
      }

      // Ki·ªÉm tra s·ª©c kh·ªèe c·ªßa nodes
      async function checkNodeHealth() {
        const primaryStatus = await checkNode(NODES.primary);
        const secondaryStatus = await checkNode(NODES.secondary);

        // T·ª± ƒë·ªông failover n·∫øu primary die
        if (
          !primaryStatus &&
          secondaryStatus &&
          currentNode === NODES.primary
        ) {
          await performFailover();
        } else if (primaryStatus && currentNode === NODES.secondary) {
          // Failback v·ªÅ primary khi n√≥ ho·∫°t ƒë·ªông l·∫°i
          await performFailback();
        }

        updateCurrentNodeUI();
        return { primaryStatus, secondaryStatus };
      }

      async function checkNode(url) {
        try {
          const response = await fetch(`${url}/status`, {
            method: "GET",
            signal: AbortSignal.timeout(2000),
          });
          const data = await response.json();
          return data.status !== undefined || data.is_leader !== undefined;
        } catch (error) {
          return false;
        }
      }

      function updateCurrentNodeUI() {
        const nodeUrlEl = document.getElementById("nodeUrl");
        const statusEl = document.getElementById("nodeStatus");
        const displayEl = document.getElementById("currentNodeDisplay");

        nodeUrlEl.textContent = currentNode;

        if (currentNode === NODES.primary) {
          displayEl.classList.remove("standby", "active");
          displayEl.style.backgroundColor = "var(--primary-red)";
        } else {
          displayEl.classList.add("active");
          displayEl.style.backgroundColor = "var(--primary-green)";
        }
      }

      async function performFailover() {
        console.log("üîÑ Performing failover to secondary node...");
        isFailover = true;
        currentNode = NODES.secondary;

        // Redirect sang port 4001
        const currentPort = window.location.port;
        if (currentPort === "4000") {
          console.log("üîÑ Redirecting to port 4001...");
          window.location.href = "http://127.0.0.1:4001/";
          return;
        }

        // Show failover alert
        const alertEl = document.getElementById("failoverAlert");
        const messageEl = document.getElementById("failoverMessage");
        messageEl.textContent =
          "‚ö†Ô∏è Node Ch√≠nh (4000) kh√¥ng kh·∫£ d·ª•ng! ƒê√£ chuy·ªÉn sang Node Ph·ª• (4001)";
        alertEl.classList.add("show");

        // Update UI
        updateCurrentNodeUI();
        await loadTasks();

        setTimeout(() => {
          alertEl.classList.remove("show");
        }, 5000);
      }

      async function performFailback() {
        console.log("‚úÖ Performing failback to primary node...");
        isFailover = false;
        currentNode = NODES.primary;

        // Redirect v·ªÅ port 4000 n·∫øu ƒëang ·ªü port 4001
        const currentPort = window.location.port;
        if (currentPort === "4001") {
          console.log("‚úÖ Redirecting back to port 4000...");
          window.location.href = "http://127.0.0.1:4000/";
          return;
        }

        // Show failback notification
        const alertEl = document.getElementById("failoverAlert");
        const messageEl = document.getElementById("failoverMessage");
        messageEl.textContent = "‚úÖ Node Ch√≠nh (4000) ƒë√£ ho·∫°t ƒë·ªông tr·ªü l·∫°i!";
        alertEl.classList.add("show");
        alertEl.style.backgroundColor = "#d4edda";
        alertEl.style.borderColor = "#c3e6cb";
        alertEl.style.color = "#155724";

        // Update UI
        updateCurrentNodeUI();
        await loadTasks();

        setTimeout(() => {
          alertEl.classList.remove("show");
          alertEl.style.backgroundColor = "";
          alertEl.style.borderColor = "";
          alertEl.style.color = "";
        }, 5000);
      }

      function startHealthCheck() {
        // Ki·ªÉm tra s·ª©c kh·ªèe m·ªói 5 gi√¢y
        healthCheckInterval = setInterval(async () => {
          await checkNodeHealth();
        }, 5000);
      }

      function handleKeyPress(event) {
        if (event.key === "Enter") {
          addTask();
        }
      }

      function showMessage(message, type = "success") {
        const element = document.getElementById(type + "Message");
        element.textContent = message;
        element.classList.add("show");
        setTimeout(() => {
          element.classList.remove("show");
        }, 3000);
      }

      async function apiRequest(endpoint, options = {}) {
        try {
          const response = await fetch(`${currentNode}${endpoint}`, {
            ...options,
            signal: AbortSignal.timeout(5000),
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          return await response.json();
        } catch (error) {
          console.error(`Request failed on ${currentNode}:`, error);

          // Th·ª≠ failover n·∫øu request th·∫•t b·∫°i
          if (currentNode === NODES.primary) {
            const secondaryOnline = await checkNode(NODES.secondary);
            if (secondaryOnline) {
              await performFailover();
              // Retry request on secondary
              const response = await fetch(
                `${currentNode}${endpoint}`,
                options
              );
              return await response.json();
            }
          }

          throw error;
        }
      }

      async function loadTasks() {
        try {
          const data = await apiRequest("/tasks");
          tasks = data.tasks || [];
          renderTasks();
        } catch (error) {
          console.error("L·ªói t·∫£i tasks:", error);
          document.getElementById("tasksList").innerHTML =
            '<div class="empty-state"><div class="empty-state-icon">‚ö†Ô∏è</div><div class="empty-state-text">Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn b·∫•t k·ª≥ node n√†o</div></div>';
        }
      }

      function renderTasks() {
        const container = document.getElementById("tasksList");
        let filteredTasks = tasks;

        if (currentFilter === "active") {
          filteredTasks = tasks.filter((t) => !t.completed);
        } else if (currentFilter === "completed") {
          filteredTasks = tasks.filter((t) => t.completed);
        }

        document.getElementById("taskCount").textContent = tasks.length;

        if (filteredTasks.length === 0) {
          container.innerHTML = `
            <div class="empty-state">
              <div class="empty-state-icon">üìÇ</div>
              <div class="empty-state-text">Ch∆∞a c√≥ c√¥ng vi·ªác n√†o. H√£y th√™m c√¥ng vi·ªác m·ªõi!</div>
            </div>
          `;
          return;
        }

        container.innerHTML = filteredTasks
          .map(
            (task) => `
          <div class="task-item ${
            task.completed ? "completed" : ""
          }" data-id="${task.id}">
            <input 
              type="checkbox" 
              class="task-checkbox" 
              ${task.completed ? "checked" : ""} 
              onchange="toggleTask('${task.id}')"
            />
            <div class="task-content">
              <div class="task-title">${escapeHtml(task.title)}</div>
              <div class="task-meta">ID: ${task.id} | ${new Date(
              task.created_at
            ).toLocaleString("vi-VN")}</div>
            </div>
            <button class="btn btn-danger" onclick="deleteTask('${task.id}')">
              X√≥a
            </button>
          </div>
        `
          )
          .join("");
      }

      async function addTask() {
        const input = document.getElementById("taskInput");
        const title = input.value.trim();

        if (!title) {
          showMessage("Vui l√≤ng nh·∫≠p t√™n c√¥ng vi·ªác!", "error");
          return;
        }

        try {
          await apiRequest("/tasks", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ title }),
          });

          input.value = "";
          showMessage("ƒê√£ th√™m c√¥ng vi·ªác th√†nh c√¥ng!");
          await loadTasks();
        } catch (error) {
          showMessage("L·ªói khi th√™m c√¥ng vi·ªác!", "error");
        }
      }

      async function addBulkTasks() {
        const input = document.getElementById("bulkTaskInput");
        const lines = input.value.split("\n").filter((line) => line.trim());

        if (lines.length === 0) {
          showMessage("Vui l√≤ng nh·∫≠p √≠t nh·∫•t m·ªôt c√¥ng vi·ªác!", "error");
          return;
        }

        try {
          const promises = lines.map((title) =>
            apiRequest("/tasks", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title: title.trim() }),
            })
          );

          await Promise.all(promises);
          input.value = "";
          showMessage(`ƒê√£ th√™m ${lines.length} c√¥ng vi·ªác th√†nh c√¥ng!`);
          await loadTasks();
        } catch (error) {
          showMessage("L·ªói khi th√™m nhi·ªÅu c√¥ng vi·ªác!", "error");
        }
      }

      async function toggleTask(id) {
        const task = tasks.find((t) => t.id === id);
        if (!task) return;

        try {
          await apiRequest(`/tasks/${id}`, {
            method: "PUT",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ completed: !task.completed }),
          });

          await loadTasks();
        } catch (error) {
          showMessage("L·ªói khi c·∫≠p nh·∫≠t c√¥ng vi·ªác!", "error");
          await loadTasks();
        }
      }

      async function deleteTask(id) {
        if (!confirm("B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a c√¥ng vi·ªác n√†y?")) return;

        try {
          await apiRequest(`/tasks/${id}`, {
            method: "DELETE",
          });

          showMessage("ƒê√£ x√≥a c√¥ng vi·ªác!");
          await loadTasks();
        } catch (error) {
          showMessage("L·ªói khi x√≥a c√¥ng vi·ªác!", "error");
        }
      }

      async function clearCompleted() {
        const completedTasks = tasks.filter((t) => t.completed);
        if (completedTasks.length === 0) {
          showMessage("Kh√¥ng c√≥ c√¥ng vi·ªác ƒë√£ ho√†n th√†nh ƒë·ªÉ x√≥a!", "error");
          return;
        }

        if (
          !confirm(
            `B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a ${completedTasks.length} c√¥ng vi·ªác ƒë√£ ho√†n th√†nh?`
          )
        )
          return;

        try {
          const promises = completedTasks.map((task) =>
            apiRequest(`/tasks/${task.id}`, { method: "DELETE" })
          );

          await Promise.all(promises);
          showMessage(`ƒê√£ x√≥a ${completedTasks.length} c√¥ng vi·ªác!`);
          await loadTasks();
        } catch (error) {
          showMessage("L·ªói khi x√≥a c√¥ng vi·ªác!", "error");
        }
      }

      function filterTasks(filter, event) {
        currentFilter = filter;

        document.querySelectorAll(".filter-btn").forEach((btn) => {
          btn.classList.remove("active");
        });

        if (event && event.target) {
          event.target.classList.add("active");
        }

        renderTasks();
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // Cleanup on page unload
      window.addEventListener("beforeunload", () => {
        if (healthCheckInterval) {
          clearInterval(healthCheckInterval);
        }
      });
    </script>
  </body>
</html>
